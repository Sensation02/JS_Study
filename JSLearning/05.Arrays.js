// #region Масиви
// Нагадування: масив це об'єкт, з цифровими іменами властивостей (0..1..2.. і тд.)
const myArray = [1, 2, 3]
console.log(myArray) // [1, 2, 3]
// кожний елемент масиву має свій індекс, який починається з 0
// --------------------------------------------------------------------------------
// створення масиву через конструктор (застарілий спосіб)
const myArray2 = new Array(1, 2, 3)
// або
const testArr = Array(6) // створює масив з 6 пустих елементів
console.log(myArray2) // [1, 2, 3]
console.table(myArray2) // вивід структури об'єкта, довжиною в 3
console.log(myArray2.length) // 3
// --------------------------------------------------------------------------------
// Порівняння масиву з об'єктом
const myObject2 = {
  0: 1,
  1: 2,
  2: 3,
  length: 3,
}
console.log(myObject2) // ми отримаємо щось дуже схоже на масив: { '0': 1, '1': 2, '2': 3, length: 3 } , але відрізняються вони прототипами (про них пізніше). Також довжина в масиві буде оновлюватися кожний раз коли туди щось додається, з об'єктом такого відбуватися не буде
// --------------------------------------------------------------------------------
// Вивід елемента під індексом:
console.log(myArray[0]) // 1
// Зміна довжини:
myArray.length = 7
// Все що далі 2 буде:
console.log(myArray[7]) // undefined
// --------------------------------------------------------------------------------
// Додавання нових елементів у масив:
myArray[3] = 'abc'
console.log(myArray) // [ 1, 2, 3, 'abc', <3 empty items> ]
myArray[4] = true
console.log(myArray) // [ 1, 2, 3, 'abc', true, <2 empty items> ]
myArray.length = 4
myArray[5] = false // додавання нового елементу в кінець масиву
console.log(myArray) // [ 1, 2, 3, 'abc', <1 empty item>, false ]
console.log(myArray.length) // 5, а було 4
// але таке додавання не зручне, тому що ми можемо не знати довжину масиву. Для цього є методи масиву. До того ж це використовує багато пам'яті.
// ================================================================================================
// Методи масиву:
// .length - властивість масиву, яка показує його довжину
console.log(myArray.length) // 5 (довжина рахується з 1, а не з 0)
console.log(myArray[myArray.length - 1]) // false (отримуємо останній елемент масиву)
myArray[myArray.length - 1] = null // змінюємо останній елемент масиву
console.log(myArray) // [ 1, 2, 3, 'abc', null ]
myArray[null] = 'test' // додаємо новий елемент в масив
console.log(myArray) // [ 1, 2, 3, 'abc', null, <1 empty item>, test ]
myArray['test'] = 'text'
console.log(myArray) // [ 1, 2, 3, 'abc', null, <1 empty item>, test, test: 'text' ] - додаємо новий елемент в масив через індекс, при чому в цього елемента є певна назва (test: 'text')
console.log(myArray.test) // text (отримуємо значення елемента масиву по індексу test. Але робити так не потрібно, бо це не є правильним використанням масиву)
// АЛЕ якщо додавати в кінець масиву, то краще використовувати метод .push()
// .push(...elements) - метод який додає елемент в кінець масиву
myArray.push('new element')
console.log(myArray) // [ 1, 2, 3, 'abc', null, <1 empty item>, test, test: 'text', 'new element' ]
// --------------------------------------------------------------------------------
// .unshift(...elements) - метод який додає елемент в початок масиву
myArray.unshift('new element 2')
console.log(myArray) // [ 'new element 2', 1, 2, 3, 'abc', null, <1 empty item>, test, test: 'text', 'new element' ]
// --------------------------------------------------------------------------------
// .shift() - метод який видаляє перший елемент масиву
myArray.shift()
console.log(myArray) // [ 1, 2, 3, 'abc', null, <1 empty item>, test, test: 'text', 'new element' ]
// --------------------------------------------------------------------------------
// .map() - метод який перебирає масив і виконує певну дію з кожним елементом масиву (повертає новий масив)
const myArray3 = myArray2.map((item) => item * 2) // дужки можна не ставити, якщо в функції тільки один параметр, це так, згадано з попередніх уроків :)
// ми перебираємо масив myArray2 і кожен елемент масиву ми помножимо на 2
// таким методом можна робити багато чого
myArray3 = myArray2.map((item) => item + 2)
// ми перебираємо масив myArray2 і кожен елемент масиву ми додаємо 2 тощо

const usersBalance = [
  { name: 'Alex', balance: 1000 },
  { name: 'Bob', balance: 1200 },
  { name: 'John', balance: 300 },
  { name: 'Jane', balance: 4400 },
  { name: 'Kate', balance: 5000 },
]
const balanceLimit = usersBalance.map((user) => {
  user.balanceLimit = 1000 - user.balance

  if (user.balance < 0) {
    return (user.balanceLimit = 0)
  } else if (user.balance >= 1000) {
    return (user.balanceLimit = 10000)
  } else {
    return (user.balanceLimit = user.balance)
  }
})
console.log(balanceLimit)
// --------------------------------------------------------------------------------
// .filter((value, index, array) => {}) - метод який перебирає масив і видаляє певні елементи масиву
const myArray4 = myArray2.filter((item) => item > 2)
// ми перебираємо масив myArray2 і видаляємо всі елементи масиву, які менші за 2
console.log(myArray4) // [ 3, 4, 5, 6, 7, 8, 9, 10 ]
myArray4 = myArray2.filter((item) => item % 2 === 0)
// ми перебираємо масив myArray2 і видаляємо всі елементи масиву, які не є парними тощо
console.log(myArray4) // [ 2, 4, 6, 8, 10 ]
// --------------------------------------------------------------------------------
// .forEach((el, index, array) => {}, thisArg) - метод який перебирає масив і виконує певну дію з кожним елементом масиву (не повертає новий масив)
myArray2.forEach((item) => console.log(item))
// ми перебираємо масив myArray2 і виводимо кожен елемент масиву в консоль
// або давай придумаємо щось цікаве
myArray2.forEach((item, index) =>
  console.log(`Елемент масиву ${index} = ${item}`),
) // Елемент масиву 0 = 1, Елемент масиву 1 = 2, Елемент масиву 2 = 3, Елемент масиву 3 = 4, Елемент масиву 4 = 5 :)
// інший приклад, якщо ми хочемо вивести всі парні елементи масиву
myArray2 = [1, 2, 3, 4, 5, 6, 7, 8, 9]
myArray2.forEach((item) => {
  if (item % 2 === 0) {
    console.log(item)
  }
}) // 2, 4, 6, 8 але в такому випадку краще використовувати метод .filter()
myArray2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 2, 32, 53, 12, 65, 4, 32]
// або ми хочемо всі парні числа масиву зробити непарних і вивести їх у новий масив
const myArray5 = []
myArray2.forEach((item) => {
  if (item % 2 === 0) {
    myArray5.push(item + 1)
  }
}) // [ 3, 5, 7, 9, 3, 33, 53, 65, 5, 33 ]
// тепер давай відфільтруємо масив так, щоб не було однакових чисел
myArray5.forEach((item, index) => {
  if (myArray5.indexOf(item) !== index) {
    myArray5.splice(index, 1)
  }
}) // [ 3, 5, 7, 9, 33, 53, 65 ] - видалилися всі однакові числа, але знову ж таки, краще використовувати метод .filter()

// Комбінації таких методів дає багато можливостей для роботи з масивами :)
// --------------------------------------------------------------------------------
// .reduce(callbackFn, initialValue) - метод який перебирає масив і виконує певну дію з кожним елементом масиву і повертає одне значення
myNewArray = [1, 2, 3, 4, 5, 10, 20]
const myArray6 = myNewArray.reduce((sum, item) => sum + item, 0)
console.log(myArray6) // 45
// тобто ми перебираємо масив myArray2 і додаємо всі елементи масиву
// 0 - це початкове значення, яке ми встановлюємо для sum, якщо ми його не встановимо, то воно буде рівне першому елементу масиву
myArray6 = myNewArray.reduce((sum, item) => sum + item, 10) // тут початкове значення sum буде 10
console.log(myArray6) // 55
myArray6 = myNewArray.reduce((sum, item) => sum + item) // тут початкове значення sum буде 1
console.log(myArray6) // 46
// тепер приклад не з числами
let strArray = ['hello', 'Vasyl', 'c', 'd', 'world']
const strArray2 = strArray
  .reduce((sum, item) => sum + item, '')
  .replace(/ /g, ', ')
console.log(strArray2) // hello, Vasyl, c, d, world
const productsCart = [
  { name: 'Milk', price: 20, count: 2 },
  { name: 'Bread', price: 10, count: 3 },
  { name: 'Meat', price: 50, count: 1 },
]
const total = productsCart.reduce(
  (sum, item) => sum + item.price * item.count,
  0,
)
console.log(total) // 130 - це сума всіх товарів в кошику
// --------------------------------------------------------------------------------
// .reduceRight(callbackFn, initialValue) - метод який перебирає масив з кінця і виконує певну дію з кожним елементом масиву і повертає одне значення
const totalPrice = productsCart.reduceRight((sum, item) => sum + item.price, 0)
console.log(totalPrice) // 80 - це сума всіх товарів в кошику
// --------------------------------------------------------------------------------
// .replace(deleted, replacer) - метод який замінює певні символи в стрічці на інші, або видаляє їх, як в прикладі вище
// --------------------------------------------------------------------------------
// .splice(start, end) - метод який дозволяє видаляти елементи масиву і додавати їх в масив з певного індексу масиву (start) і до певного індексу (end) масиву (не включаючи його) і повертає масив з видаленими елементами масиву (якщо ми видаляємо їх) або масив з доданими елементами масиву (якщо ми додаємо їх)
myArray2 = [1, 2, 3, 4, 5, 6, 7, 8, 9]
myArray2.splice(0, 1) // видаляємо перший елемент масиву
console.log(myArray2) // [ 2, 3, 4, 5, 6, 7, 8, 9 ]
myArray2.splice(0, 2) // видаляємо перші два елементи масиву
console.log(myArray2) // [ 4, 5, 6, 7, 8, 9 ]
// тобто перший параметр це індекс елемента з якого починаємо видаляти, а другий параметр це кількість елементів які ми видаляємо
// якщо другий параметр не вказувати, то видаляться всі елементи масиву починаючи з індексу який ми вказали
myArray2.splice(0) // видаляємо всі елементи масиву
console.log(myArray2) // []
// а тепер давайте додамо елементи в масив
myArray2.splice(0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9) // додаємо елементи в масив
console.log(myArray2) // [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
// --------------------------------------------------------------------------------
// .slice(from, amount) - метод який дозволяє вибрати певну частину масиву i повертає у новий масив
myArray2 = [1, 2, 3, 4, 5, 6, 7, 8, 9]
const myNewArray3 = myArray2.slice(0, 3) // вибираємо перші три елементи масиву
console.log(myNewArray3) // [ 1, 2, 3 ]
// --------------------------------------------------------------------------------
// Array.from() - метод який перетворює псевдомасив в масив
const myArray31 = Array.from('hello world')
console.log(myArray31) // [ 'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd' ]

let myString2 = 'hello world'
myArray = Array.from(myString2)
console.log(myArray) // [ 'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd' ]

myArray = Array.from(myString2, (item) => item.toUpperCase())
console.log(myArray) // [ 'H', 'E', 'L', 'L', 'O', ' ', 'W', 'O', 'R', 'L', 'D' ]

myArray = Array.from(myString2, (item, index) =>
  index % 2 ? item.toUpperCase() : item.toLowerCase(),
)
console.log(myArray) // [ 'h', 'E', 'l', 'L', 'o', ' ', 'w', 'O', 'r', 'L', 'd' ]

myArray = Array.from(myString2, (item, index) =>
  index % 2 ? item.toUpperCase() : item.toLowerCase(),
).join('')
console.log(myArray) // hElLo wOrLd

myStringObj = {
  0: 'hello',
  1: 'world',
  2: '!!!',
  length: 3,
}
myArray = Array.from(myStringObj, (item) => item.toUpperCase())
console.log(myArray) // [ 'HELLO', 'WORLD', '!!!' ]

myArray = Array.from(myStringObj, (item, index) =>
  index % 2 ? item.toUpperCase() : item.toLowerCase(),
)
console.log(myArray) // [ 'hello', 'WORLD', '!!!' ]
// --------------------------------------------------------------------------------
// Array.isArray() - метод який перевіряє чи є масивом
console.log(Array.isArray(myArray)) // true
console.log(Array.isArray(myStringObj)) // false
// --------------------------------------------------------------------------------
// Array.of() - метод який створює масив з переданих аргументів
myArray = Array.of(1, 2, 3, 4, 5, 6, 7, 8, 9)
console.log(myArray) // [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
myArray = Array.of(myStringObj, myArray31)
console.log(myArray) // [ { '0': 'hello', '1': 'world', '2': '!!!', length: 3 }, [ 'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd' ] ]
// --------------------------------------------------------------------------------
// .at() - метод який повертає елемент масиву по індексу
myArray = [1, 2, 3, 4, 5, 6, 7, 8, 9]
console.log(myArray.at(0)) // 1
// --------------------------------------------------------------------------------
// .pop() - метод який видаляє останній елемент масиву і повертає його
const lastEl = myArray.pop()
console.log(myArray) // [ 1, 2, 3, 4, 5, 6, 7, 8 ]
console.log(lastEl) // 9
// --------------------------------------------------------------------------------
// .includes() - метод який перевіряє чи є елемент в масиві
console.log(myArray.includes(1)) // true
console.log(myArray.includes(10)) // false
// --------------------------------------------------------------------------------
// .indexOf() - метод який повертає індекс елемента масиву
console.log(myArray.indexOf(1)) // 0
console.log(myArray.indexOf(10)) // -1 (тобто елемента в масиві немає)
// --------------------------------------------------------------------------------
// .lastIndexOf() - метод який повертає індекс останнього елемента масиву
myArray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 1]
console.log(myArray.lastIndexOf(1)) // 9
// --------------------------------------------------------------------------------
// .concat() - метод який об'єднує два масиви в один масив і повертає його
myArray = [1, 2, 3, 4, 5, 6, 7, 8, 9]
myArray2 = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
myArray3 = myArray.concat(myArray2) // об'єднуємо два масиви
console.log(myArray3) // [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,11, 12, 13, 14, 15, 16, 17, 18, 19 ]
// --------------------------------------------------------------------------------
// .copyWithin() - метод який копіює частину масиву в інший масив і повертає його (перезаписує елементи)
myArray = [1, 2, 3, 4, 5, 6, 7, 8, 9]
myArray.copyWithin(0, 3, 6) // копіюємо елементи з індексу 3 по індекс 6 в масив з індексу 0
console.log(myArray) // [ 4, 5, 6, 4, 5, 6, 7, 8, 9 ]
// тобто спочатку вибираємо місце куди вставляємо, потім вибираємо звідки копіюємо і до якого індексу
// --------------------------------------------------------------------------------
// .fill() - метод який заповнює масив однаковими елементами
myArray = [1, 2, 3, 4, 5, 6, 7, 8, 9]
myArray.fill(0) // заповнюємо масив нулями
console.log(myArray) // [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
myArray.fill(1, 3, 6) // заповнюємо масив одиницями з індексу 3 по індекс 6
console.log(myArray) // [ 0, 0, 0, 1, 1, 1, 0, 0, 0 ]
// --------------------------------------------------------------------------------
// .reverse() - метод який розвертає масив і повертає його
myArray = [1, 2, 3, 4, 5, 6, 7, 8, 9]
myArray.reverse()
console.log(myArray) // [ 9, 8, 7, 6, 5, 4, 3, 2, 1 ]
// --------------------------------------------------------------------------------
// .sort((a, b) => {}) - метод який сортує масив, де a - перший елемент, b - другий елемент
myArray = [1, 22, 3, 44, 5, 66, 7, 8, 91]
myArray.sort((a, b) => {
  if (a > b) return 1 // якщо a > b то повертаємо 1 (тобто міняємо місцями)
  if (a < b) return -1 // якщо a < b то повертаємо -1 (тобто не міняємо місцями)
}) // тобто сортуємо по зростанню
console.log(myArray) // [ 1, 3, 5, 7, 8, 22, 44, 66, 91 ]
// або інший варіант:
myArray.sort((a, b) => a - b) // сортуємо по зростанню
myArray.sort((a, b) => b - a) // сортуємо по спаданню
myArray.sort(() => Math.random() - 0.5) // сортуємо випадковим чином
console.log(myArray) // [ 91, 66, 44, 22, 8, 7, 5, 3, 1 ]
// --------------------------------------------------------------------------------
// .every() - метод який перевіряє чи всі елементи масиву відповідають заданому умові
myArray = [1, 2, 3, 4, 5, 6, 7, 8, 9]
console.log(myArray.every((item) => item > 0)) // true
console.log(myArray.every((item) => item > 1)) // false
// --------------------------------------------------------------------------------
// .some() - метод який перевіряє чи хоча б один елемент масиву відповідає заданому умові
console.log(myArray.some((item) => item > 8)) // true
console.log(myArray.some((item) => item > 9)) // false - бо немає елементів більших за 9
// --------------------------------------------------------------------------------
// .find() - метод який повертає перший елемент масиву який відповідає заданому умові
console.log(myArray.find((item) => item > 8)) // 9
console.log(myArray.find((item) => item > 9)) // undefined - бо немає елементів більших за 9

const userList = [
  { id: 1, name: 'Vlad', age: 25 },
  { id: 23, name: 'Elena', age: 17 },
  { id: 58, name: 'Ivan', age: 18 },
  { id: 92, name: 'Iryna', age: 23 },
]

let userAge
const userBigAge = userList.find((user) => {
  if (user.age > 18) {
    return (userAge = `${user.name}\`s age is: ${user.age}`)
  }
})
console.log(userAge) // Vlad`s age is: 25
console.log(userBigAge) // { id: 1, name: 'Vlad', age: 25 }
// --------------------------------------------------------------------------------
// .findIndex((value, index, array) => {}) - метод який повертає індекс першого елемента масиву який відповідає заданому умові
console.log(userList.findIndex((user) => user.age > 18)) // 0 - бо перший елемент масиву відповідає умові
// --------------------------------------------------------------------------------
// .findLastIndex((value, index, array) => {}) - метод який повертає індекс останнього елемента масиву який відповідає заданому умові
console.log(userList.findLastIndex((user) => user.age > 18)) // 3 - бо останній елемент масиву відповідає умові
// --------------------------------------------------------------------------------
// .values() - метод який повертає ітератор з значеннями масиву
console.log(userList.values()) // Object [Array Iterator] {} - ітератор
const iter = userList.values() // створюємо ітератор зі значеннями масиву
for (const value of iter) {
  console.log(value) // { id: 1, name: 'Vlad', age: 25 } ... - значення масиву
}
// --------------------------------------------------------------------------------
// .keys() - метод який повертає ітератор з індексами масиву
console.log(userList.keys()) // Object [Array Iterator] {} - ітератор
const iter2 = userList.keys() // створюємо ітератор з індексами масиву
for (const value of iter2) {
  console.log(value) // 0 ... - індекси масиву
}
// --------------------------------------------------------------------------------
// .join(separator) - метод який перетворює масив в рядок, розділяючи елементи масиву заданим роздільником
console.log(myArray.join()) // 1,2,3,4,5,6,7,8,9
console.log(myArray.join('')) // 123456789
console.log(myArray.join(' ')) // 1 2 3 4 5 6 7 8 9 тощо

const productCart = ['milk', 'bread', 'eggs', 'cheese']
console.log(productCart.join(', ')) // milk, bread, eggs, cheese
// --------------------------------------------------------------------------------
// .flat(depth) - метод який вирівнює масив до заданої глибини (по замовчуванню 1) і повертає новий масив
myArray = [1, 2, 3, [4, 5, 6, [7, 8, 9]]]
console.log(myArray.flat()) // [ 1, 2, 3, 4, 5, 6, [ 7, 8, 9 ] ] - вирівняли до глибини 1
console.log(myArray.flat(2)) // [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ] - вирівняли до глибини 2
// --------------------------------------------------------------------------------
// .flatMap((value, index, array) => {}, thisArg) - метод який вирівнює масив до глибини 1 і повертає новий масив
// в якому кожен елемент масиву перетворюється в елемент відповідно до callback-функції
myArray = [1, 2, 3, [4, 5, 6, [7, 8, 9]]]
const flatArray = myArray.flatMap((item) => item * 2, 3)
console.log(flatArray) // [ 2, 4, 6, 8, 10, 12, [ 7, 8, 9 ] ] - вирівняли до глибини 1 і помножили на 2
// ================================================================================================
// delete - оператор який видаляє елемент з масиву (але не видаляє його індекс)
delete myArray[myArray.length - 1] // видаляємо останній елемент масиву
console.log(myArray) // [ 1, 2, 3, 'abc', null, <1 empty item>, test ]
// АЛЕ якщо видаляти останній елемент, то краще використовувати метод .pop()
// --------------------------------------------------------------------------------
// Вкладеність масивів:
myArray2 = [1, 2, 3, [4, 5, 6]] // масив в масиві або двовимірний масив
console.log(myArray2) // [ 1, 2, 3, [ 4, 5, 6 ] ]
// Щоб вивести елемент масиву, який є масивом, то потрібно вказати індекс вкладеного масиву:
console.log(myArray2[3][1]) // 5 - виводимо елемент масиву, який є масивом, тобто звертаємося по індексу до масиву в масиві, потім до елемента вже у вкладеному масиві
myArray2 = [1, 2, 3, [4, 5, 6, [7, 8, 9]]] // масив в масиві в масиві або тривимірний масив
// Виведення такого масиву є аналогічним, тільки потрібно вказати більше індексів:
console.log(myArray2[3][3][1]) // 8 - перша 3 - це індекс вкладеного масиву, друга 3 - це індекс вкладеного масиву вкладеного масиву, а 1 - це індекс елемента вкладеного масиву вкладеного масиву (тавтологія :D)
// --------------------------------------------------------------------------------
// Ітерація по масиву:
// for of - цикл який дозволяє перебрати всі елементи масиву
for (const item of myArray) {
  console.log(item) // 1, 2, 3, 'abc', null, <1 empty item>, test, test: 'text'
}
// Або приклад з локацією, тобто спершу створимо двовимірний масив із координатами
const location = [
  [1, 2],
  [3, 4],
  [5, 6],
]
// Потім виконаємо ітерацію по масиву:
for (const coord of location) {
  console.log(coord) // [ 1, 2 ], [ 3, 4 ], [ 5, 6 ]
  // тобто в тілі такого циклу ми виконуємо дію над кожним елементом масиву
  // у даному випадку ми виводимо кожен елемент масиву в консоль
}
// також можна вивести кожну координату окремо:
for (const coord of location) {
  console.log(coord[0], coord[1]) // 1 2, 3 4, 5 6
}
// або ще такий варіант:
for (const coord of location) {
  for (const item of coord) {
    console.log(item) // 1, 2, 3, 4, 5, 6
  }
}
// --------------------------------------------------------------------------------
// for in - цикл який дозволяє перебрати всі індекси масиву
for (const index in myArray) {
  console.log(index) // 0, 1, 2, 3, 4, 5, 6, 7
} // тобто в тілі такого циклу ми виконуємо дію над кожним індексом масиву
// на основі прикладу з координатами
for (const index in location) {
  console.log(index) // 0, 1, 2
} // вивели індекси кожного елемента масиву, тут їх 3
// а якщо масив двовимірний?
for (const index in location) {
  for (const item in location[index]) {
    console.log(item) // 0 1, 0 1, 0 1
  }
} // через "," виводяться масиви, а вже всередині виводяться індекси кожного елемента вкладеного масиву
// також можна написати так:
for (const index in location) {
  console.log(location[index][0], location[index][1]) // 1 2, 3 4, 5 6
} // тобто виводимо кожну координату окремо через ","
// або ще такий варіант:
for (const index in location) {
  for (const item in location[index]) {
    console.log(location[index][item]) // 1, 2, 3, 4, 5, 6
  }
} // кожний елемент вкладених масивів виводимо окремо
// ще зробимо так:
for (const index in location) {
  console.log(location[index]) // [ 1, 2 ], [ 3, 4 ], [ 5, 6 ]
  for (const item in location[index]) {
    console.log(location[index][item]) // 1, 2, 3, 4, 5, 6
  }
} // спочатку виводимо вкладені масиви, а потім виводимо кожний елемент вкладеного масиву

// все те саме тільки за допомоги стандартного циклу for
for (let i = 0; i < location.length; i++) {
  console.log(location[i]) // [ 1, 2 ], [ 3, 4 ], [ 5, 6 ]
  for (let j = 0; j < location[i].length; j++) {
    console.log(location[i][j]) // 1, 2, 3, 4, 5, 6
  }
}
// --------------------------------------------------------------------------------
// порівняння масивів
const list1 = [1, 2, 3]
const list2 = [1, 2, 3]
console.log(list1 === list2) // false - тому що, по суті, це два різних об'єкти. Кожен масив є унікальним
// --------------------------------------------------------------------------------
// Перетворення масивів в рядки
console.log(list1.toString()) // 1,2,3
// насправді toString вбудований в кожний об'єкт мови JavaScript
// а тепер порівняємо два масиви які ми перетворили в рядки
console.log(list1.toString() === list2.toString()) // true - тому що, ми порівняли два рядки які мають однаковий вміст
// --------------------------------------------------------------------------------
// Створюємо новий масив на основі іншого масиву
const list3 = list1
console.log(list3) // [ 1, 2, 3 ]
// а тепер порівняємо два масиви, новий зі старим на основі якого ми його створили
console.log(list3 === list1) // true - тому що, ми створили новий масив на основі старого які мають однаковий вміст
// таке створення є простим, далі будемо розглядати інші способи створення масивів
// --------------------------------------------------------------------------------
// Деструктуризація масивів - це коли ми витягуємо елементи із масиву
// простий варіант:
const [l1, l2, l3] = list1
console.log(l1, l2, l3) // 1 2 3
// тобто через [] дужки ми витягуємо елементи із масиву, вказуючи їх назви
// таким чином ми створили 3 перемінні із елементами масиву в кожній
// ще можна створити одну перемінну, а в ній знаходиться один елемент з масиву за вказаним індексом
const [l4] = list1[0] // 1
// перемінних може бути менше ніж елементів масиву
const [l5, l6] = list1 // 1 2
// можна ще пропустити елементи масиву
const [, , l7] = list1 // 3, тобто пропустили 1 і 2
// а тепер витягнемо елементи із вкладеного масиву на основі масиву з координатами
const [[x1, y1], [x2, y2], [x3, y3]] = location
console.log(x1, y1, x2, y2, x3, y3) // 1 2 3 4 5 6
// можна перший елемент вкласти в перемінну, а решту вкласти в масив
const [x4, ...y4] = location[0]
console.log(x4, y4) // 1 [ 2 ] - тобто в перемінну x4 вклали перший елемент, а решту вклали в масив y4
// це відбувається за допомогою оператора розподілу (...), який вказує що решта елементів вкладається в масив

// тепер створимо деструктуризацію нового масиву з результату деструктуризації іншого масиву
const [anotherList1, anotherList2] = y4 // 2 - тобто в перемінну anotherList1 вклали перший елемент, а решту вклали в масив anotherList2
// --------------------------------------------------------------------------------
// Створення нового масиву на основі деструктуризації іншого масиву
const list4 = [...list1] // [ 1, 2, 3 ]
// при порівнянні двох масивів, ми отримаємо false, тому що це, знову ж таки, два різних об'єкти
// а якщо ми створюємо новий масив на основі іншого який не має в собі нічого?
list1 = null
const list5 = [...list1] // [ null ] - помилка, тому що ми не можемо витягнути елементи із масиву який не існує. Але можна створити пустий масив з використанням оператора "або"
list5 = [...(list1 || [])] // [ ] - тепер ми створили пустий масив

// об'єднання неіснуючого масиву із іншим масивом
const list6 = [list1, ...(list1 || [])]
console.log(list6) // [ null, [] ] - тобто ми об'єднали не існуючий масив із пустим масивом, що насправді не відбулося. Якби він не був null, то вони б об'єднались правильно
// --------------------------------------------------------------------------------
// Обмін елементів масиву через деструктуризацію
list1 = [1, 2, 3]
list2 = [4, 5, 6]
;[list1, list2] = [list2, list1]
console.log(list1, list2) // [ 4, 5, 6 ] [ 1, 2, 3 ] - тобто ми обміняли елементи масивів
// --------------------------------------------------------------------------------
// Деструктуризація у функціях
function printFullName(firstName, lastName) {
  return `${firstName} ${lastName}`
}
console.log(printFullName(`John`, `Doe`)) // John Doe
// а тепер зробимо те саме, але через деструктуризацію
function printFullName2(...arg) {
  console.log(arg)
}
printFullName2(`John`, `Doe`) // [ `John`, `Doe` ] - тобто ми отримали масив із двома елементами
// або так
function printFullName3(...arg) {
  return arg.toString()
}
console.log(printFullName3(`John`, `Doe`)) // John,Doe - тобто ми отримали рядок із двома елементами
// можна ще написати з додаванням пробілу між словами які хочемо додати
function printFullName4(...arg) {
  return arg.join(` `) // - додаємо пробіл між елементами вже з використанням методу join
}
console.log(printFullName4(`John`, `Doe`))
// John Doe - тобто ми отримали рядок із двома елементами між якими пробіл
// інший приклад
function sumAllNumbers(...numbers) {
  let sum = 0 // - змінна для зберігання суми
  for (const number of numbers) {
    sum += number // - додаємо до суми кожен елемент масиву numbers
  }
  return sum // - повертаємо суму
}
console.log(sumAllNumbers(1, 2, 3, 4, 5)) // 15

// тепер все те саме але через функцію будемо повертати масив
function sumAllNumbers2(...numbers) {
  let sum = 0 // - змінна для зберігання суми
  for (const number of numbers) {
    sum += number // - додаємо до суми кожен елемент масиву numbers
  }
  return [sum, numbers.length] // - повертаємо масив
}
console.log(sumAllNumbers2(1, 2, 3, 4, 5)) // [ 15, 5 ] - тобто ми отримали масив із двома елементами, де перший елемент - сума, а другий - кількість елементів

// повернемося до функції printFullName3
// як нам витягнути потрібні змінні?
function printFullName5([firstName, lastName, ...arg]) {
  return `${firstName} ${lastName} ${arg.length ? `(${arg.join(' ')})` : ''}` // - тут ми використали тернарний оператор, який перевіряє чи є елементи в масиві arg, якщо є, то він виводить їх, якщо немає, то нічого не виводить
}
console.log(printFullName5(`John`, `Doe`, `Hello`, `John`)) // John Doe (Hello John) - тобто ми отримали рядок із двома елементами із пробілом між ними, а також із дужками із елементами масиву arg
console.log(printFullName5(`John`, `Doe`)) // John Doe - тобто ми отримали рядок із двома елементами із пробілом між ними, але так як масив arg пустий, то нічого не виводиться

// або якщо в нас arg має тільки один елемент то він виведе його без дужок:
console.log(printFullName5(`John`, `Doe`, `Hello`)) // John Doe Hello
// #endregion
